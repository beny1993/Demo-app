import { ApiErrorCodes, flattenErrors, } from '../lib/response.js';
import { GraphQLClient as BaseGraphQLClient, } from 'graphql-request';
import { parseToken } from '../lib/token.js';
export class GraphqlClient extends BaseGraphQLClient {
    constructor(options) {
        const { graphqlUrl = 'https://app.tribe.so/api/gateway', accessToken, clientId, clientSecret, } = options;
        const params = {};
        if (options.fetch)
            params.fetch = options.fetch;
        super(graphqlUrl, params);
        this.accessToken = accessToken;
        this.onError = options.onError;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.notifyOnTokenExpiration = !!options.notifyOnTokenExpiration;
        if (this.notifyOnTokenExpiration) {
            this.tokenExpirationHandler(accessToken);
        }
    }
    tokenExpirationHandler(token) {
        clearTimeout(this.tokenExpirationTimeout);
        const parsedToken = parseToken(token);
        if (!parsedToken) {
            return;
        }
        const diff = new Date(parsedToken.exp * 1000).getTime() - new Date().getTime();
        const timeout = diff - 60 * 1000; // invoke the error handler one minute sooner
        // This is due to setTimeout using a 32 bit int to store the delay so the max value allowed would be
        if (timeout > 2147483647) {
            return;
        }
        this.tokenExpirationTimeout = setTimeout(() => {
            var _a;
            (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, [
                {
                    code: ApiErrorCodes.INVALID_ACCESS_TOKEN,
                    message: 'Invalid access token',
                },
            ], this, null);
        }, timeout);
    }
    getBasicToken() {
        return Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64');
    }
    async authorizedRequest(options) {
        const { query, variables = {}, customToken = null, useBasicToken = false, } = options;
        if (useBasicToken) {
            this.setHeader('Authorization', `Basic ${this.getBasicToken()}`);
        }
        else {
            this.setHeader('Authorization', `Bearer ${customToken || this.accessToken}`);
        }
        return this.request(query, variables).catch((error) => {
            var _a, _b;
            if ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.errors) {
                const normalizedError = flattenErrors(error.response.errors);
                error.response.errors = normalizedError;
                (_b = this.onError) === null || _b === void 0 ? void 0 : _b.call(this, normalizedError, this, error);
            }
            // eslint-disable-next-line no-throw-literal
            throw error;
        });
    }
    setToken(accessToken) {
        this.accessToken = accessToken;
        if (this.notifyOnTokenExpiration) {
            this.tokenExpirationHandler(accessToken);
        }
    }
}
