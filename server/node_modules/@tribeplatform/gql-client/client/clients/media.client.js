var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { createEmojisGQLMutation, createFilesGQLMutation, createImageGQLMutation, embedGQLQuery, updateImageGQLMutation, } from '../../graphql/index.js';
export class MediaClient {
    constructor(client) {
        this.client = client;
    }
    async embed(variables) {
        const result = await this.client.authorizedRequest({
            query: embedGQLQuery(),
            variables,
        });
        return result.embed;
    }
    async updateImage(variables) {
        const result = await this.client.authorizedRequest({
            query: updateImageGQLMutation(),
            variables,
        });
        return result.updateImage;
    }
    async createEmojis(input) {
        const result = await this.client.authorizedRequest({
            query: createEmojisGQLMutation(),
            variables: {
                input,
            },
        });
        return result === null || result === void 0 ? void 0 : result.createEmojis;
    }
    async createImages(variables) {
        const result = await this.client.authorizedRequest({
            query: createImageGQLMutation(),
            variables: {
                input: variables,
            },
        });
        return result === null || result === void 0 ? void 0 : result.createImages;
    }
    async createFiles(variables) {
        const result = await this.client.authorizedRequest({
            query: createFilesGQLMutation(),
            variables: {
                input: variables,
            },
        });
        return result === null || result === void 0 ? void 0 : result.createFiles;
    }
    async uploadFiles(input, handleError) {
        const signedUrls = await this.createFiles(input.map((_a) => {
            var { file: _ } = _a, input = __rest(_a, ["file"]);
            return input;
        }));
        const output = [];
        const promises = signedUrls.map((signedUrl, index) => {
            const { file, name, size, extension } = input[index];
            const formData = new FormData();
            const parsedFields = JSON.parse(signedUrl.fields);
            // The order of appended key-value into the formData matters.
            Object.entries(parsedFields).forEach(([key, value]) => {
                formData.append(key, String(value));
            });
            formData.append('Content-Type', file.type);
            formData.append('file', file);
            return fetch(signedUrl.signedUrl, {
                method: 'POST',
                body: formData,
            })
                .then(() => {
                output.push({
                    id: signedUrl.mediaId,
                    url: signedUrl.mediaUrl,
                    name,
                    downloadUrl: signedUrl.mediaDownloadUrl,
                    size,
                    extension,
                });
            })
                .catch(e => {
                if (handleError) {
                    handleError({
                        fileName: name,
                        message: e === null || e === void 0 ? void 0 : e.message,
                    });
                }
                else {
                    throw e;
                }
            });
        });
        await Promise.all(promises);
        return output;
    }
    async uploadImages(input, handleError) {
        const output = [];
        const signedUrls = await this.createImages(input.map((_a) => {
            var { file } = _a, rest = __rest(_a, ["file"]);
            return (Object.assign({ contentType: file.type, name: file.name }, rest));
        }));
        const promises = signedUrls.map((signedUrl, index) => {
            const { file, name } = input[index];
            const formData = new FormData();
            const parsedFields = JSON.parse(signedUrl.fields);
            // The order of appended key-value into the formData matters.
            Object.entries(parsedFields).forEach(([key, value]) => {
                formData.append(key, String(value));
            });
            formData.append('Content-Type', file.type);
            formData.append('file', file);
            return fetch(signedUrl.signedUrl, {
                method: 'POST',
                body: formData,
            })
                .then(r => r.text())
                .then(() => {
                output.push({
                    id: signedUrl.mediaId,
                    url: signedUrl.mediaUrl,
                    urls: signedUrl.urls,
                    cropX: input[index].cropX,
                    cropY: input[index].cropY,
                    cropZoom: input[index].cropZoom,
                    name: input[index].name,
                    cropHeight: input[index].cropHeight,
                    cropWidth: input[index].cropWidth,
                    downloadUrl: signedUrl.mediaDownloadUrl,
                });
            })
                .catch(error => {
                if (handleError) {
                    handleError({
                        fileName: name,
                        message: error === null || error === void 0 ? void 0 : error.message,
                    });
                }
                else {
                    throw error;
                }
            });
        });
        await Promise.all(promises.filter(Boolean));
        return output;
    }
}
